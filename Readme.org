#+TITLE: Dice library
#+AUTHOR: Mikhail Erementchouk
#+EMAIL: merement@gmail.com
#+DATE: <2021-08-29 Sun>
#+OPTIONS: tex: t LaTeX: t toc:1 ^:{}
#+DESCRIPTION:

* Usage

Julia's implementation of a research dynamic Ising solver based on nonlinear relaxations. A Julia library that contains all the necessary functions, packages, as well as other tools to run Ising machines using various relaxations and methods. You may find it useful to create your own code to suppliment functions found here. 

* Installation

1. Begin by cloning this repository to your computer. It does not not matter where you clone it to, only that you may access it via Julia. 
2. Change your working directory by using the ~cd~ or the relavant command in terminal to the cloned Dice repository.
3. While having Dice as your working directory, activate the Julia REPL by using the command ~julia~. 
4. Open the package manager by typing ~]~, then type in ~dev .~ to add Dice to the list of available packages in Julia.

To confirm that Dice is working correctly, run the [[simple.jl][simple.jl]] file. What you should get a random initial spin state (assigned to ~state[1]~) as well as the max-cut spin state noted as:

~Final Max-Cut state: Int8[-1, 1, 1, -1, 1, -1, 1]~

* Running First Simulation

There are a few steps to run a simulation using Dice:

- Creating a graph
- Creating the model
- Running the model

** Create A Graph

This graph represents the system of which the Ising machine will "run" on. Where each node is a particle that can take a spin $\sigma$ where $\sigma \in {-1,1}$ along as a continous variable $x$ where $x \in [-1,1)$. $x$ may or may not be used depending on the coupling function and method used (VERIFICATION NEEDED). Then one must add the edges which describe the coupling between the particles. 

If an edge exists, then there will be interaction between those particles, otherwise there will be none. For example, if two particles have opposite spin, then the energy of the system decreases. If there is an edge between any two particles, then their spin interacion will be considered when computing the energy. If an edge does not exist, and say the spin of the particles were the same, the energy would not change as there is no interaction between the two particles due to the lack of an edge. 

One can also give the edges different weights, or simply leave it as a simple binary value where $1$ means an edge exists while $0$ means that an edge doesn't between two nodes.

Graphs here are made using the ~Graphs~ and ~SimpleWeightedGraphs~ Julia packages. Their respective documentation can be found below:

- [[https://juliagraphs.org/Graphs.jl/dev/][Graphs Documentation]]

- [[https://juliagraphs.org/SimpleWeightedGraphs.jl/stable/][SimpleWeightedGraphs Documentation]]

** Creating the Model

Here, Dice will take the graph created and turn it into a runable model. It requires a few key things:
- The graph created
- The coupling function
- Scale (optional)

If scale is not given, then Dice will create a scale based on the number of nodes in the graph. 

There are several coupling functions available, which relate the continous variable $x$ to the energy of the system. All coupling functions may be found in [[src/dynamical_kernels.jl][dynamical_kernels.jl]].

Next one must specify the intial configuration of spins and continous variables $x$. This is done through the use of ~get_random_hybrid~, which generates random spin configuration and random initial $x$ values. Note that you will need to specify the range of the $x$ value, which can be simply the width of the interval, $w$, ($x \in [-w/2, w/2]$) or the bounds of the interval from $[a,b]$, ($x \in [a,b]). Store this intitial state in a separate variable from your model. 

** Running the Model

Once you have the initial state, you can run the model to achieve the ground state. Depending on what you are looking for, you can run the model in two ways:

- Using ~propagate~, which will return the final ground state of the model. 
- Using ~trajectories~, which will return the intermediary steps of the computation as well as the final ground state.

Look in [[simple.jl][simple.jl]] for an example on how to do all of this. You may also look in the source code to find other functions that may suit your needs.

* Content

[[file:dev][src]] contains the development version of the library

[[file:cases/][cases]] holds particular "releases" (see the description inside) and applications

The main page is https://github.com/merement/Dice.git


